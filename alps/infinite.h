/*****************************************************************************
*
* Cluster-MC: Cluster Algorithm Monte Carlo Methods
*
* Copyright (C) 2014 by Synge Todo <wistaria@phys.s.u-tokyo.ac.jp>
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
* DEALINGS IN THE SOFTWARE.
*
*****************************************************************************/

// O(N) Swendsen-Wang Cluster Algorithm for Infinite Ragnge Ising Model

#include <alps/parapack/worker.h>
#include <algorithm>
#include <vector>
#include "looper/union_find.h"
#include "looper/power.h"

using looper::power2;
using looper::power4;

class infinite_worker : public alps::parapack::mc_worker {
private:
  typedef alps::parapack::mc_worker super_type;
  typedef looper::union_find::node fragment_t;

public:
  infinite_worker(alps::Parameters const& params) :
    super_type(params), T(params["T"]), N(params["N"]),
    r_time(engine(), boost::exponential_distribution<>(N / T)),
    mcs(params), spins(N, 1), fragments(N), to_flip(N) {
  }
  virtual ~infinite_worker() {}

  static std::string program() {
    return "O(N) Swendsen-Wang Cluster Algorithm for Infinite Range Ising Model";
  }
  static std::string copyright() {
    return program() + "\n" +
      "  Copyright (C) 2014 by Synge Todo <wistaria@phys.s.u-tokyo.ac.jp>";
  }
      
  void init_observables(alps::Parameters const&, alps::ObservableSet& obs) {
    obs << alps::RealObservable("Number of Clusters")
        << alps::RealObservable("Magnetization (unimproved)")
        << alps::RealObservable("Magnetization^2 (unimproved)")
        << alps::RealObservable("Magnetization^4 (unimproved)")
        << alps::RealObservable("Magnetization^2")
        << alps::RealObservable("Magnetization^4");
  }

  bool is_thermalized() const { return mcs.is_thermalized(); }
  double progress() const { return mcs.progress(); }

  void run(alps::ObservableSet& obs) {
    ++mcs;

    // initialize cluster information
    std::fill(fragments.begin(), fragments.end(), fragment_t());

    // cluster generation
    for (double t = r_time(); t < 1; t += r_time()) {
      int s0 = N * uniform_01();
      int s1 = N * uniform_01();
      if (spins[s0] == spins[s1]) unify(fragments, s0, s1);
    }

    // assign cluster id & accumulate cluster properties
    int nc = 0;
    double mag2 = 0, mag4 = 0;
    for (int f = 0; f < N; ++f) {
      if (fragments[f].is_root()) {
        fragments[f].set_id(nc++);
        double w = fragments[f].weight();
        mag2 += power2(w);
        mag4 += power4(w);
      }
    }
    for (int f = 0; f < N; ++f) fragments[f].set_id(cluster_id(fragments, f));

    // flip spins
    for (int c = 0; c < nc; ++c) to_flip[c] = (uniform_01() < 0.5);
    double mu = 0;
    for (int s = 0; s < N; ++s) {
      if (to_flip[fragments[s].id()]) spins[s] ^= 1;
      mu += 2 * spins[s] - 1;
    }
    
    obs["Number of Clusters"] << (double)nc;
    obs["Magnetization (unimproved)"] << mu;
    obs["Magnetization^2 (unimproved)"] << power2(mu);
    obs["Magnetization^4 (unimproved)"] << power4(mu);
    obs["Magnetization^2"] << mag2;
    obs["Magnetization^4"] << (3 * power2(mag2) - 2 * mag4);
  }

  void save(alps::ODump& dp) const { dp << mcs << spins; }
  void load(alps::IDump& dp) { dp >> mcs >> spins; }

private:
  double T; // temperature
  int N; // number of lattice sites
  boost::variate_generator<engine_type&, boost::exponential_distribution<> > r_time;
  alps::mc_steps mcs;
  std::vector<int> spins; // spin configuration
  std::vector<fragment_t> fragments;
  std::vector<bool> to_flip;
};

class infinite_evaluator : public alps::parapack::simple_evaluator {
public:
  infinite_evaluator(alps::Parameters const&) {}
  void evaluate(alps::ObservableSet& obs) const {
    {
      alps::RealObsevaluator m2 = obs["Magnetization^2 (unimproved)"];
      alps::RealObsevaluator m4 = obs["Magnetization^4 (unimproved)"];
      alps::RealObsevaluator binder("Binder Ratio of Magnetization (unimproved)");
      binder = power2(m2) / m4;
      obs.addObservable(binder);
    }
    {
      alps::RealObsevaluator m2 = obs["Magnetization^2"];
      alps::RealObsevaluator m4 = obs["Magnetization^4"];
      alps::RealObsevaluator binder("Binder Ratio of Magnetization");
      binder = power2(m2) / m4;
      obs.addObservable(binder);
    }
  }
};
